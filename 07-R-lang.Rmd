#  Object-oriented programming
<p><a href="" id="index-object_002doriented"></a></p>
<p>Object-oriented programming is a style of programming that has become popular in recent years. Much of the popularity comes from the fact that it makes it easier to write and maintain complicated systems. It does this through several different mechanisms.</p>
<p>Central to any object-oriented language are the concepts of class and of methods. A <em>class</em> is a definition of an object. Typically a class contains several <em>slots</em> that are used to hold class-specific information. An object in the language must be an instance of some class. Programming is based on objects or instances of classes.</p>
<p>Computations are carried out via <em>methods</em>. Methods are basically <a href="" id="index-function-24"></a> functions that are specialized to carry out specific calculations on objects, usually of a specific class. This is what makes the language object oriented. In R, <em>generic functions</em> are used to determine the appropriate method. The generic function is responsible for determining the class of its argument(s) and uses that information to select the appropriate method.</p>
<p>Another feature of most object-oriented languages is the concept of inheritance. In most programming problems there are usually many objects that are related to one another. The programming is considerably simplified if some components can be reused.</p>
<p>If a class inherits from another class then generally it gets all the slots in the parent class and can extend it by adding new slots. On method dispatching (via the generic functions) if a method for the class does not exist then a method for the parent is sought.</p>
<p>In this chapter we discuss how this general strategy has been implemented in R and discuss some of the limitations within the current design. One of the advantages that most object systems impart is greater consistency. This is achieved via the rules that are checked by the compiler or interpreter. Unfortunately because of the way that the object system is incorporated into R this advantage does not obtain. Users are cautioned to use the object system in a straightforward manner. While it is possible to perform some rather interesting feats these tend to lead to obfuscated code and may depend on implementation details that will not be carried forward.</p>
<p>The greatest use of object oriented programming in R is through <code class="calibre7">print</code> methods, <code class="calibre7">summary</code> methods and <code class="calibre7">plot</code> methods. These methods allow us to have one generic <a href="" id="index-function_002c-generic"></a> function call, <code class="calibre7">plot</code> say, that dispatches on the type of its argument and calls a plotting function that is specific to the data supplied.</p>
<p>In order to make the concepts clear we will consider the implementation of a small system designed to teach students about probability. In this system the objects are probability functions and the methods we will consider are methods for finding moments and for plotting. Probabilities can always be represented in terms of the cumulative distribution function but can often be represented in other ways. For example as a density, when it exists or as a moment generating function when it exists.</p>
<hr />
<p><a href="" id="Definition"></a> <a href="" id="Definition-1"></a></p>
<h3 id="definition" class="section">5.1 Definition</h3>
<p>Rather than having a full-fledged <a href="" id="index-object_002doriented-1"></a> object-oriented system R has a class system and a mechanism for dispatching based on the class of an object. The dispatch mechanism for interpreted code relies on four special objects that are stored in the evaluation frame. These special objects are <code class="calibre7">.Generic</code>, <code class="calibre7">.Class</code>, <code class="calibre7">.Method</code> and <code class="calibre7">.Group</code>. There is a separate dispatch mechanism used for internal functions and types that will be discussed elsewhere.</p>
<p>The class system is facilitated through the <code class="calibre7">class</code> attribute. This attribute is a character vector of class names. So to create an object of class <code class="calibre7">&quot;foo&quot;</code> one simply attaches a class attribute with the string ‘&quot;foo&quot;’ in it. Thus, virtually anything can be turned in to an object of class <code class="calibre7">&quot;foo&quot;</code>.</p>
<p>The object system makes use of <a href="" id="index-function_002c-generic-1"></a> <em>generic functions</em> via two dispatching functions, <code class="calibre7">UseMethod</code> and <code class="calibre7">NextMethod</code>. The typical use of the object system is to begin by calling a generic function. This is typically a very simple function and consists of a single line of code. The system function <code class="calibre7">mean</code> is just such a function,</p>
<div class="example">
<pre class="example1"><code>&gt; mean
function (x, ...)
UseMethod(&quot;mean&quot;)</code></pre>
</div>
<p>When <code class="calibre7">mean</code> is called it can have any number of arguments but its first argument is special and the class of that first argument is used to determine which method should be called. The variable <code class="calibre7">.Class</code> is set to the class attribute of <code class="calibre7">x</code>, <code class="calibre7">.Generic</code> is set to the string <code class="calibre7">&quot;mean&quot;</code> and a search is made for the correct method to invoke. The class attributes of any other arguments to <code class="calibre7">mean</code> are ignored.</p>
<p>Suppose that <code class="calibre7">x</code> had a class attribute that contained <code class="calibre7">&quot;foo&quot;</code> and <code class="calibre7">&quot;bar&quot;</code>, in that order. Then R would first search for a function called <code class="calibre7">mean.foo</code> and if it did not find one it would then search for a function <code class="calibre7">mean.bar</code> and if that search was also unsuccessful then a final search for <code class="calibre7">mean.default</code> would be made. If the last search is unsuccessful R reports an error. It is a good idea to always write a default method. Note that the functions <code class="calibre7">mean.foo</code> etc. are referred to, in this context, as methods.</p>
<p><code class="calibre7">NextMethod</code> provides another mechanism for dispatching. A <a href="" id="index-function-25"></a> function may have a call to <code class="calibre7">NextMethod</code> anywhere in it. The determination of which method should then be invoked is based primarily on the current values of <code class="calibre7">.Class</code> and <code class="calibre7">.Generic</code>. This is somewhat problematic since the method is really an ordinary function and users may call it directly. If they do so then there will be no values for <code class="calibre7">.Generic</code> or <code class="calibre7">.Class</code>.</p>
<p>If a method is invoked directly and it contains a call to <code class="calibre7">NextMethod</code> then the first argument to <code class="calibre7">NextMethod</code> is used to determine the <a href="" id="index-function_002c-generic-2"></a> generic function. An error is signalled if this argument has not been supplied; it is therefore a good idea to always supply this argument.</p>
<p>In the case that a method is invoked directly the class attribute of the first argument to the method is used as the value of <code class="calibre7">.Class</code>.</p>
<p>Methods themselves employ <code class="calibre7">NextMethod</code> to provide a form of inheritance. Commonly a specific method performs a few operations to set up the data and then it calls the next appropriate method through a call to <code class="calibre7">NextMethod</code>.</p>
<p>Consider the following simple example. A point in two-dimensional Euclidean space can be specified by its Cartesian (x-y) or polar (r-theta) coordinates. Hence, to store information about the location of the point, we could define two classes, <code class="calibre7">&quot;xypoint&quot;</code> and <code class="calibre7">&quot;rthetapoint&quot;</code>. All the ‘xypoint’ data structures are lists with an x-component and a y-component. All ‘rthetapoint’ objects are lists with an r-component and a theta-component.</p>
<p>Now, suppose we want to get the x-position from either type of object. This can easily be achieved through <a href="" id="index-function_002c-generic-3"></a> generic functions. We define the generic function <code class="calibre7">xpos</code> as follows.</p>
<div class="example">
<pre class="example1"><code>xpos &lt;- function(x, ...)
    UseMethod(&quot;xpos&quot;)</code></pre>
</div>
<p>Now we can define methods:</p>
<div class="example">
<pre class="example1"><code>xpos.xypoint &lt;- function(x) x&#36;x
xpos.rthetapoint &lt;- function(x) x&#36;r * cos(x&#36;theta)</code></pre>
</div>
<p>The user simply calls the function <code class="calibre7">xpos</code> with either representation as the argument. The internal dispatching method finds the class of the object and calls the appropriate methods.</p>
<p>It is pretty easy to add other representations. One need not write a new generic function only the methods. This makes it easy to add to existing systems since the user is only responsible for dealing with the new representation and not with any of the existing representations.</p>
<p>The bulk of the uses of this methodology are to provide specialized printing for objects of different types; there are about 40 methods for <code class="calibre7">print</code>.</p>
<hr />
<p><a href="" id="Inheritance"></a> <a href="" id="Inheritance-1"></a></p>
<h3 id="inheritance" class="section">5.2 Inheritance</h3>
<p><a href="" id="index-evaluation-4"></a></p>
<p>The class attribute of an object can have several elements. When a <a href="" id="index-function_002c-generic-4"></a> generic function is called the first inheritance is mainly handled through <code class="calibre7">NextMethod</code>. <code class="calibre7">NextMethod</code> determines the method currently being evaluated, finds the next class from th</p>
<p>FIXME: something is missing here</p>
<hr />
<p><a href="" id="Method-dispatching"></a> <a href="" id="Method-dispatching-1"></a></p>
<h3 id="method-dispatching" class="section">5.3 Method dispatching</h3>
<p><a href="" id="index-function_002c-generic-5"></a></p>
<p>Generic functions should consist of a single statement. They should usually be of the form <code class="calibre7">foo &lt;- function(x, ...) UseMethod(&quot;foo&quot;, x)</code>. When <code class="calibre7">UseMethod</code> is called, it determines the appropriate method and then that method is invoked with the same arguments, in the same order as the call to the generic, as if the call had been made directly to the method.</p>
<p>In order to determine the correct method the class attribute of the first argument to the generic is obtained and used to find the correct method. The <a href="" id="index-name-8"></a> name of the generic function is combined with the first element of the class attribute into the form, <code class="calibre7">generic.class</code> and a function with that name is sought. If the function is found then it is used. If no such function is found then the second element of the class attribute is used, and so on until all the elements of the class attribute have been exhausted. If no method has been found at that point then the method <code class="calibre7">generic.default</code> is used. If the first argument to the generic function has no class attribute then <code class="calibre7">generic.default</code> is used. Since the introduction of namespaces the methods may not be accessible by their names (i.e. <code class="calibre7">get(&quot;generic.class&quot;)</code> may fail), but they will be accessible by <code class="calibre7">getS3method(&quot;generic&quot;,&quot;class&quot;)</code>.</p>
<p><a href="" id="index-object-4"></a></p>
<p>Any object can have a <code class="calibre7">class</code> attribute. This attribute can have any number of elements. Each of these is a string that defines a class. When a generic function is invoked the class of its first argument is examined.</p>
<hr />
<p><a href="" id="UseMethod"></a> <a href="" id="UseMethod-1"></a></p>
<h3 id="usemethod" class="section">5.4 UseMethod</h3>
<p><a href="" id="index-UseMethod"></a></p>
<p><code class="calibre7">UseMethod</code> is a special function and it behaves differently from other function calls. The syntax of a call to it is <code class="calibre7">UseMethod(generic, object)</code>, where generic is the name of the generic function, object is the object used to determine which method should be chosen. <code class="calibre7">UseMethod</code> can only be called from the body of a function.</p>
<p><a href="" id="index-evaluation-5"></a></p>
<p><code class="calibre7">UseMethod</code> changes the evaluation model in two ways. First, when it is invoked it determines the next method (function) to be called. It then invokes that function using the current evaluation <a href="" id="index-environment-13"></a> environment; this process will be described shortly. The second way in which <code class="calibre7">UseMethod</code> changes the evaluation environment is that it does not return control to the calling function. This means, that any statements after a call to <code class="calibre7">UseMethod</code> are guaranteed not to be executed.</p>
<p>When <code class="calibre7">UseMethod</code> is invoked the generic function is the specified value in the call to <code class="calibre7">UseMethod</code>. The object to dispatch on is either the supplied second argument or the first argument to the current function. The class of the argument is determined and the first element of it is combined with the name of the generic to determine the appropriate method. So, if the generic had name <code class="calibre7">foo</code> and the class of the object is <code class="calibre7">&quot;bar&quot;</code>, then R will search for a method named <code class="calibre7">foo.bar</code>. If no such method exists then the inheritance mechanism described above is used to locate an appropriate method.</p>
<p>Once a method has been determined R invokes it in a special way. Rather than creating a new evaluation <a href="" id="index-environment-14"></a> environment R uses the environment of the current function call (the call to the generic). Any <a href="" id="index-assignment-7"></a> assignments or evaluations that were made before the call to <code class="calibre7">UseMethod</code> will be in effect. The arguments that were used in the call to the generic are rematched to the formal arguments of the selected method.</p>
<p>When the method is invoked it is called with arguments that are the same in number and have the same names as in the call to the generic. They are matched to the arguments of the method according to the standard R rules for argument matching. However the object, i.e. the first argument has been evaluated.</p>
<p>The call to <code class="calibre7">UseMethod</code> has the effect of placing some special objects in the evaluation frame. They are <code class="calibre7">.Class</code>, <code class="calibre7">.Generic</code> and <code class="calibre7">.Method</code>. These special objects are used to by R to handle the method dispatch and inheritance. <code class="calibre7">.Class</code> is the class of the object, <code class="calibre7">.Generic</code> is the name of the generic function and <code class="calibre7">.Method</code> is the name of the method currently being invoked. If the method was invoked through one of the internal interfaces then there may also be an object called <code class="calibre7">.Group</code>. This will be described in Section <a href="#Group-methods">Group methods</a>. After the initial call to <code class="calibre7">UseMethod</code> these special variables, not the object itself, control the selection of subsequent methods.</p>
<p>The body of the method is then evaluated in the standard fashion. In particular variable look-up in the body follows the rules for the method. So if the method has an associated environment then that is used. In effect we have replaced the call to the generic by a call to the method. Any local <a href="" id="index-assignment-8"></a> assignments in the frame of the generic will be carried forward into the call to the method. Use of this <em>feature</em> is discouraged. It is important to realize that control will never return to the generic and hence any expressions after a call to <code class="calibre7">UseMethod</code> will never be executed.</p>
<p>Any arguments to the generic that were evaluated prior to the call to <code class="calibre7">UseMethod</code> remain evaluated.</p>
<p>If the first argument to <code class="calibre7">UseMethod</code> is not supplied it is assumed to be the name of the current function. If two arguments are supplied to <code class="calibre7">UseMethod</code> then the first is the name of the method and the second is assumed to be the object that will be dispatched on. It is evaluated so that the required method can be determined. In this case the first argument in the call to the generic is not evaluated and is discarded. There is no way to change the other arguments in the call to the method; these remain as they were in the call to the generic. This is in contrast to <code class="calibre7">NextMethod</code> where the arguments in the call to the next method can be altered.</p>
<hr />
<p><a href="" id="NextMethod"></a> <a href="" id="NextMethod-1"></a></p>
<h3 id="nextmethod" class="section">5.5 NextMethod</h3>
<p><a href="" id="index-NextMethod"></a></p>
<p><code class="calibre7">NextMethod</code> is used to provide a simple inheritance mechanism.</p>
<p>Methods invoked as a result of a call to <code class="calibre7">NextMethod</code> behave as if they had been invoked from the previous method. The arguments to the inherited method are in the same order and have the same names as the call to the current method. This means that they are the same as for the call to the generic. However, the expressions for the arguments are the names of the corresponding formal arguments of the current method. Thus the arguments will have values that correspond to their value at the time NextMethod was invoked.</p>
<p>Unevaluated arguments remain unevaluated. Missing arguments remain missing.</p>
<p>The syntax for a call to <code class="calibre7">NextMethod</code> is <code class="calibre7">NextMethod(generic, object, ...)</code>. If the <code class="calibre7">generic</code> is not supplied the value of <code class="calibre7">.Generic</code> is used. If the <code class="calibre7">object</code> is not supplied the first argument in the call to the current method is used. Values in the ‘...’ argument are used to modify the arguments of the next method.</p>
<p>It is important to realize that the choice of the next method depends on the current values of <code class="calibre7">.Generic</code> and <code class="calibre7">.Class</code> and not on the object. So changing the object in a call to <code class="calibre7">NextMethod</code> affects the arguments received by the next method but does not affect the choice of the next method.</p>
<p>Methods can be called directly. If they are then there will be no <code class="calibre7">.Generic</code>, <code class="calibre7">.Class</code> or <code class="calibre7">.Method</code>. In this case the <code class="calibre7">generic</code> argument of <code class="calibre7">NextMethod</code> must be specified. The value of <code class="calibre7">.Class</code> is taken to be the class attribute of the object which is the first argument to the current function. The value of <code class="calibre7">.Method</code> is the name of the current function. These choices for default values ensure that the behaviour of a method doesn’t change depending on whether it is called directly or via a call to a generic.</p>
<p>An issue for discussion is the behaviour of the ‘...’ argument to <code class="calibre7">NextMethod</code>. The White Book describes the behaviour as follows:</p>
<p><a href="" id="index-name-9"></a></p>
<p>- named arguments replace the corresponding arguments in the call to the current method. Unnamed arguments go at the start of the argument list.</p>
<p>What I would like to do is:</p>
<p>-first do the argument matching for NextMethod; -if the object or generic are changed fine -first if a named list element matches an argument (named or not) the list value replaces the argument value. - the first unnamed list element</p>
<p>Values for lookup: Class: comes first from .Class, second from the first argument to the method and last from the object specified in the call to NextMethod</p>
<p>Generic: comes first from .Generic, if nothing then from the first argument to the method and if it’s still missing from the call to NextMethod</p>
<p>Method: this should just be the current function name.</p>
<hr />
<p><a href="" id="Group-methods"></a> <a href="" id="Group-methods-1"></a></p>
<h3 id="group-methods" class="section">5.6 Group methods</h3>
<p>For several types of <a href="" id="index-function_002c-internal-1"></a> internal functions R provides a dispatching mechanism for operators. This means that operators such as <code class="calibre7">==</code> or <code class="calibre7">&lt;</code> can have their behaviour modified for members of special classes. The functions and operators have been grouped into three categories and group methods can be written for each of these categories. There is currently no mechanism to add groups. It is possible to write methods specific to any function within a group.</p>
<p>The following table lists the functions for the different Groups.</p>
<dl>
<dt>‘Math’</dt>
<dd><p>abs, acos, acosh, asin, asinh, atan, atanh, ceiling, cos, cosh, cospi, cumsum, exp, floor, gamma, lgamma, log, log10, round, signif, sin, sinh, sinpi, tan, tanh, tanpi, trunc</p>
</dd>
<dt>‘Summary’</dt>
<dd><p>all, any, max, min, prod, range, sum</p>
</dd>
<dt>‘Ops’</dt>
<dd><p><code class="calibre7">+</code>, <code class="calibre7">-</code>, <code class="calibre7">*</code>, <code class="calibre7">/</code>, <code class="calibre7">^</code>, <code class="calibre7">&lt;</code> , <code class="calibre7">&gt;</code>, <code class="calibre7">&lt;=</code>, <code class="calibre7">&gt;=</code>, <code class="calibre7">!=</code>, <code class="calibre7">==</code>, <code class="calibre7">%%</code>, <code class="calibre7">%/%</code>, <code class="calibre7">&amp;</code>, <code class="calibre7">|</code>, <code class="calibre7">!</code></p>
</dd>
</dl>
<p>For operators in the Ops group a special method is invoked if the two operands taken together suggest a single method. Specifically, if both operands correspond to the same method or if one operand corresponds to a method that takes precedence over that of the other operand. If they do not suggest a single method then the default method is used. Either a group method or a class method dominates if the other operand has no corresponding method. A class method dominates a group method.</p>
<p>When the group is Ops the special variable <code class="calibre7">.Method</code> is a string vector with two elements. The elements of <code class="calibre7">.Method</code> are set to the name of the method if the corresponding argument is a member of the class that was used to determine the method. Otherwise the corresponding element of <code class="calibre7">.Method</code> is set to the zero length string, <code class="calibre7">&quot;&quot;</code>.</p>
<hr />
<p><a href="" id="Writing-methods"></a> <a href="" id="Writing-methods-1"></a></p>
<h3 id="writing-methods" class="section">5.7 Writing methods</h3>
<p>Users can easily write their own methods and generic functions. A <a href="" id="index-function_002c-generic-6"></a> generic function is simply a function with a call to <code class="calibre7">UseMethod</code>. A method is simply a function that has been invoked via method dispatch. This can be as a result of a call to either <code class="calibre7">UseMethod</code> or <code class="calibre7">NextMethod</code>.</p>
<p>It is worth remembering that methods can be called directly. That means that they can be entered without a call to <code class="calibre7">UseMethod</code> having been made and hence the special variables <code class="calibre7">.Generic</code>, <code class="calibre7">.Class</code> and <code class="calibre7">.Method</code> will not have been instantiated. In that case the default rules detailed above will be used to determine these.</p>
<p>The most common use of <a href="" id="index-function_002c-generic-7"></a> generic functions is to provide <code class="calibre7">print</code> and <code class="calibre7">summary</code> methods for statistical objects, generally the output of some model fitting process. To do this, each model attaches a class attribute to its output and then provides a special method that takes that output and provides a nice readable version of it. The user then needs only remember that <code class="calibre7">print</code> or <code class="calibre7">summary</code> will provide nice output for the results of any analysis.</p>
<hr />
<p><a href="" id="Computing-on-the-language"></a> <a href="" id="Computing-on-the-language-1"></a></p>
<div id="calibre_pb_13" class="calibre5">

